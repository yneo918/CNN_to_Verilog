OUTPUT_FILE.write('module top\n')
OUTPUT_FILE.write('	#(parameter WIDTH = 8)\n')
OUTPUT_FILE.write('	(x, z, clk, ctrl, en);\n')
OUTPUT_FILE.write('\n')
OUTPUT_FILE.write('	input clk, ctrl;\n')
OUTPUT_FILE.write('	input en;\n')
OUTPUT_FILE.write('	input [WIDTH-1:0] x;\n')
OUTPUT_FILE.write('	logic [WIDTH-1:0] x_demux[0:150-1];\n')
OUTPUT_FILE.write('	output [WIDTH*2+$clog2(118)-1:0] z;\n')
OUTPUT_FILE.write('	logic [WIDTH-1:0] x_reg[0:150-1];\n')
OUTPUT_FILE.write('	logic [WIDTH*2+$clog2(118)-1:0] z_reg;\n')
OUTPUT_FILE.write('\n')
OUTPUT_FILE.write('	genvar i;\n')
OUTPUT_FILE.write('	layer #(.WIDTH(WIDTH)) conv(.x(x_reg), .z(z_reg));\n')
OUTPUT_FILE.write('	demultiplexer_1d #(.WIDTH(WIDTH), .MAX(150)) demux(.x(x), .clk(clk), .en(en_in), .z(x_demux));\n')
OUTPUT_FILE.write('	generate\n')
OUTPUT_FILE.write('		for (i = 0; i < 150; i++) begin\n')
OUTPUT_FILE.write('			register_n #(.N(WIDTH)) reg_in(.clk(clk), .reg_e(ctrl), .reg_in(x_demux[i]), .reg_out(x_reg[i]));\n')
OUTPUT_FILE.write('		end\n')
OUTPUT_FILE.write('	endgenerate\n')
OUTPUT_FILE.write('	register_n #(.N(WIDTH*2+$clog2(118))) reg_out(.clk(clk), .reg_e(ctrl), .reg_in(z_reg), .reg_out(z));\n')
OUTPUT_FILE.write('\n')
OUTPUT_FILE.write('endmodule\n')
